---
title: 进程同步
author: zhugenmi
date: 2024-10-16 15:11
categories: [操作系统, 理论]
tags: [operating system]
description: 
---

## 1 进程同步的概念

### 1.1 进程同步

异步环境下的一组并发进程因直接制约而互相发送消息、进行互相合作、互相等待，使得各进程按一定的速度执行的过程称为**进程同步**。具有同步关系的一组并发进程称为**合作进程**，合作进程间互相发送的信号称为**消息或事件**。

### 1.2 主要任务

使并发进程之间能有效地共享资源和相互合作，从而使程序执行具有可再现性。



### 1.3 进程间的制约关系

- **间接制约--互斥关系**
  因共享资源而使并发执行的各进程之间产生的关系，叫做间接制约关系，又叫做互斥(mutual exclusion)关系。这种关系可用“进程-资源-进程”来描述。

- **直接制约--同步关系**
  某进程在某些同步点上等待另一进程为它提供消息，在未获得消息之前，该进程处于等待状态，获得消息后被唤醒进入就绪态，此后，才能继续运行。进程间的这种制约关系叫作直接制约关系，又叫同步(synchronism)关系。可用“进程-进程”来描述。

>同步与互斥表示了进程之间的相互依赖又相互制约、相互合作又相互竞争的关系。

### 1.4 临界资源

**临界资源**：一段时间内只允许一个进程使用的资源。如打印机、磁带机等都属于临界资源，也称为**互斥资源**或**共享变量**。

**临界区**(critical section)：进程访问临界资源的那段**代码**。

访问临界资源的描述：

```
Repeat
    entry section     //进入区：检查有无进程进入
    critical section  //临界区：进程访问临界资源的代码
    exit section      //退出区：将访问标志复位
    remainder section //保留区：其他处理
Until false
```

### 1.5 同步机制应遵循的准则

- **空闲让进**：当无进程处于临界区，应允许一个请求进入临界区的进程立即进入自己的临界区。
- **忙则等待**：已有进程处于其临界区，其它试图进入临界区的进程必须等待。
- **有限等待**：等待进入临界区的进程不能“死等”
- **让权等待**：不能进入临界区的进程，应释放CPU，避免“忙等”

### 1.6 进程同步机制

实现进程协作（同步/互斥）的措施和方法，称为进程同步机制（或机构）。

包括软件同步机制（编程解决临界区问题，现在很少采用）、硬件同步机制（锁机制）、信号量机制（有效、应用广泛）、管程机制。

## 2 软件同步机制

Peterson解决方案

## 3 硬件同步机制

### 3.1 锁机制

用变量`lock`代表某个共享临界资源的状态，称为“锁”。

当`lock=false`时，表示资源空闲，锁开，可以访问；当`lock=true`时，表示资源被占用，锁闭，暂时不能访问。

### 3.2 如何上锁、开锁？

检查`lock`的值；如果`lock`为`true`，反复检测；如果`lock`为`false`，马上将锁置为`true`，表示立即占用该临界资源，程序进入临界区执行（即上锁操作）；临界资源使用完毕，将`lock`置`false`（开锁）。

### 3.3 锁机制实现方法

- 关中断
- Test-and-Set指令
  ![](Images/4-0Test-and-Set指令.png)

- Swap指令
  ![](Images/4-1Swap指令.png)

## 4 <font color="red">信号量机制</font>

### 4.1 信号量

**信号量(Semaphores)**：是一种数据结构，是进程同步的工具。操作系统利用信号量的状态对并发进程和共享资源进行控制和管理。

信号量是整形变量。当变量值 ≥ 0 时，表示绿灯，进程执行；当变量值 ＜ 0 时，表示红灯，进程停止执行。

### 4.2 信号量的一般结构和PCB队列

信号量是一个确定的二元组（s，q），s是一个具有非负初值的整型变量，q是一个初始状态为空的队列。

```c
struct semaphore{
    s:integer;  //s:为一整形值
    q:list of process; //q:为进程链表，用于链接所有等待该类资源进程
}
```

**信号量基本概念：**

- 信号量可以赋初值，且初值为非负数
- 信号量的值可以修改，但只能由P、V操作来访问
- 信号量中整数的值为**正**表示**有多少个资源可以利用**
- 信号量中整数的值为**负**表示**有多少个进程等候使用这个资源**

### 4.3 P、V原语操作

#### 4.3.1 P操作

P操作：wait()，**申请**一个单位资源。

P(s)表示申请一个资源，即信号灯值减1，若结果为负数，则该进程被阻塞，并插入等待队列中，否则可以继续执行。

#### 4.3.2 V操作

V操作：signal()，**释放**一个单位资源

V(s)是表示信号灯值加1，若结果大于零，该进程继续执行，否则，要帮助唤醒等待队列上的一个进程。

### 4.4 用P、V操作实现互斥

1. 框图描述：两个进程利用信号灯的P、V操作实现互斥。
   ![](Images/4-2框图描述.png)

2. 程序描述：实现互斥时，对信号量的P、V操作通常成对出现在同一进程中，通常是先P再V。
   ![](Images/4-2程序描述.png)

3. 分析：信号灯可能的取值
   两个并发进程，对同一个临界资源的访问，互斥信号的值仅取1、0和-1三个值。
   mutex=1 表示没有进程进入临界区
   mutex=0 表示有一个进程进入临界区
   mutex=-1 表示一个进程进入临界区，另一个进程等待进入。
4. 用P、V操作实现互斥的例子
   ![](Images/4-3用P、V操作实现互斥的例子.png)

### 4.5 用P、V操作实现同步

例如，进程P1和P2需要代码段C1比C2先运行。设：`semaphores s=0; //主要用于传递信号`
![](Images/4-4用P、V操作实现同步.png)

在同步关系中，同一信号量的wait和signal操作必须放在相关的进程中！即：

```c
P1(){
  C1;
  signal(s); //发送信号
  ...
}
P2(){
  ...
  wait(s); //等待信号
  C2;
}
```

### 4.6 利用信号量来描述前趋关系

分析：

- 前趋关系是一种同步关系，两个相邻进程须设一个信号量
- 信号量初值设为0
- 同一信号量的wait、signal操作必须放在相关的进程代码中
  ![](Images/4-5利用信号量来描述前趋关系.png)

## 5 管程机制

### 5.1 管程定义

一个管程定义了一个**数据结构**和能为并发进程所执行（在该数据结构上）的**一组操作**，这组操作能同步进程和改变管程中的数据。
![](Images/4-6管程定义.png)

### 5.2 互斥和同步操作

#### 5.2.1 互斥

- 管程中的变量只能被管程中的操作访问
- 任何时候只有一个进程在管程中操作
- 类似临界区
- 由编译器完成

#### 5.2.2 同步

- 条件变量：当调用管程过程的进程无法运行时，用于阻塞进程的一种信号量。`condition x,y;`
- 唤醒和阻塞操作
  阻塞操作wait:`x.wait()`进程阻塞直到另外一个进程调用`x.signal()`唤醒它；

## 6 经典进程的同步问题

互斥分析基本方法：![image-20230210120239758](Images/4-11互斥分析方法.png)

同步分析基本方法：

![image-20230210120339916](Images/4-12同步分析基本方法.png)

### 6.1 生产者-消费者问题

#### 6.1.1 情形1：单生产者-单消费者-单缓冲区

![](Images/4-7单生产者-单消费者-单缓冲区.png)

 缓冲区“满”时，Q才可继续执行，否则等待P发送数据；
缓冲区“空”时，P才可继续执行，否则等待Q取走数据；

![](Images/4-7单生产者-单消费者-单缓冲区1.png)

算法描述：

- P进程只能在缓冲区“空”时放产品，设置信号量empty；
- Q进程只能在缓冲区“满”时取产品，设置信号量full；
- 先设置信号量：empty初值为1，full初值为0.

![](Images/4-7单生产者-单消费者-单缓冲区2.png)

#### 6.1.2 单生产者-单消费者-多缓冲区

![](Images/4-8单生产者-单消费者-多缓冲区0.png)

至少有1个缓冲区“满”时，Q才可继续执行，否则等待P发送数据；
至少有1个缓冲区“空”时，P才可继续执行，否则等待Q取走数据。
![](Images/4-8单生产者-单消费者-多缓冲区1.png)

算法描述：

- 先设置信号量：empty初值为n，full初值为0
- 设整型变量in（指向空缓冲区）、out（指向满缓冲区）

![](Images/4-8单生产者-单消费者-多缓冲区2.png)

#### 6.1.3 多生产者-多消费者-多缓冲区

1. 问题描述
   
   **若干**进程通过有限的共享缓冲区交换数据。其中，P进程不断写入，而Q进程不断读出；共享缓冲区共有n个；**任何时刻只能有一个进程可对共享缓冲区进行操作**。

2. 分析：
   
- 生产者必须先生产消费者才能消费
- 缓冲池未满，生产者可生产
- 缓冲池未空，消费者可消费
- 对缓冲池的操作不能同时进行

3. 思考：

- 生产者进程之间的关系？（互斥）
- 消费者进程之间的关系？（互斥）
- 生产者和消费者之间的关系？（同时存在同步和互斥关系）
  同步：P→Q：数据；Q→P：空缓冲区
  互斥：缓冲区是一个有限资源，当P向空缓冲区发送数据时，Q取数据，则可能出现数据混乱。

4. 信号量的设定
   
   设定原则：信号量代表资源的可用数量。
   （1）信号量**empty**，表示**可用空缓冲区**资源数量，**初值为n**；
   （2）信号量**full**，表示**可用满缓冲区**资源数量，**初值为0**；
   （3）互斥信号量**mutex**，表示**互斥**使用缓冲区，**初值为1**；
   （4）两个P操作放在一起，顺序至关重要，**同步P操作放在互斥P操作前**，而两个V操作顺序无关紧要。

5. 流程图
   ![](Images/4-9多生产者-多消费者-多缓冲区0.png)

6. 算法描述
   ![](Images/4-9多生产者-多消费者-多缓冲区1.png)

### 6.2 哲学家就餐问题

#### 问题描述

有五个哲学坐在一圆桌蒡 ，桌中央有一盘通心粉 ， 每人面前有一支空盘子，每两人之问放一根筷子 。每个哲学象的行为是思考 ， 感到饥俄 ，然后吃通心粉 ；为了吃通心粉 ， 每个哲学象必须拿到两支筷子，并且每个人只能直接从自己的左边或右边去取筷子 。

#### 分析

- 筷子是临界资源，只能由相邻哲学家**互斥**使用
- 哲学家不能从邻座夺取筷子，并且需用两只筷子就餐

#### 信号量设置

一个信号量表示一个筷子，5个信号量构成信号量组：`semaphore c[5]={1,1,1,1,1};`

![image-20230210111630324](Images/1-10哲学家就餐.png)

#### 算法

>死锁:两个或多个进程无限期地等待一个事件的发生，而该事件正是由其中的一个等待进程引起的。
>
>饥饿:无限期地阻塞，进程永远无法从信号量等待队列中移去。

三种解决死锁的方法：

（1）至多允许4位去拿左边的筷子

（2）当左右筷子均可用时，才允许拿筷子就餐（AND信号量机制）

```c
main()
{
    semaphore c[5]={1,1,1,1,1};
    cobegin
        p1();p2();p3();p4();p5();
    coend
}

pi() //第i个哲学家的活动描述
{
    while(true)
    {
        思考();
        P(c[i],c[(i+1)%5]);
        吃饭();
        V(c[i],c[(i+1)%5]);
    }
}
```



（3）规定奇数号的哲学家先拿左边的筷子，然后去拿右边的筷子；偶数号哲学家相反

### 6.3 读者-写者问题

#### 问题描述

例如 ， 一个飞机订票系统 ， 其中有许多竞争的进程试图读写其中的数据 。 多个进程同时读数据库是可以接受的 ， 但如果一个进程正在更新（ 写 ） 数据库 ， 则所有的其他进程都不能访问该数据库 ， 即使读操作也不行 。

读者一写者问题描述 ： 有两组并发进程 ： 读者和写者 ， 共享一组数据区（ 数据库 、 文件 、 内存区等 ） 。

- 允许多个读者进程同时读 
- 不允许多个写者进程同时写 
- 若有写者进程正在写 ， 则不允许读者读数据

#### 分析

| 读-写关系 | 互斥     |
| --------- | -------- |
| 写-写关系 | 互斥     |
| 读-读关系 | 允许并行 |

如果读者到，

（1）如果无读者、写者，则新读者可以读

（2）如果有写者等待，但有其它读者正在读，则新读者也可以读

（3）如果有写者正在写，则读者等待

如果写者到，

（1）如果无读者，则新写者可以写

（2）如果有读者，则新写者等待

（3）如果有其它写者，则新写者等待

#### 信号量设定

- 设代表数据集资源的信号量`wmutex`（初值为1），用于实现读-写互斥以及写-写互斥
- 设计数器`readcount`（初值为0），计算当前读者人数，设互斥信号量`rmutex`（初值为1）对共享变量`readcount`进行互斥操作
- 当`readcount`由0变为1时，第一个读者进入，需要该读者进行`P(wmutex)`操作，以便读写互斥
- 当读者退出时，`readcount`减1。当`readcount=0`时，最后一个读者退出，需要进行`V(wmutex)`操作，以允许写者进程进入。

#### 算法

```c
reader()
{
    while(true)
    {
        P(rmutex);
        if(readcount==0) P(wmutex);
        readcount++;
        V(rmutex);
        读操作();
        P(rmutex);
        readcount--;
        if(readcount==0) V(wmutex); //允许写者进程进入
        V(rmutex);
    }
}

writer()
{
    while(true)
    {
        P(wmutex);
        写操作();
        V(wmutex);
    }
}

main()
{
    semaphore rmutex=1; //对readcount互斥使用
    semaphore wmutex=1; //读-写以及写-写互斥
    int readcount=0; //读者计数器
    cobegin
        reader();writer(); //并发进程
    coend
}
```

### 6.4 三个经典问题的应用

1. 生产者 / 消费者问题 ： 又被称作“**有限缓冲区**”问题 ， 即至少一个生产者与至少一个消费者针对一个公用的初始大小固定的缓冲区进行操作 。
2. 哲学家进餐问题 ： 对于**互斥访问有限资源**的竞争问题 ( 如 I/O 设备）一类的建模过程十分有用 。
3. 读者 / 写者问题 ： **数据库访问建**模 、 **访问文件**等等有用 。

#### 信号量的物理含义

- 信号量初值应该**大于等于0**
- S>0 表示有S个**可用**资源
- S=0 表示**无**资源可用
- S<0 表示**等待**队列中有|S|个进程
- P(S) 或 wait(S) 表示**申请**一个资源（同步中表示**等待**S消息）
- V(S) 或 signal(S) 表示**释放**一个资源（同步中表示**发送**S消息）

#### PV操作的使用

1. PV操作必须成对出现，**互斥**时，PV操作处于**同一**进程；**同步**时，PV操作处于**不同进程。
2. 两个P操作放在一起。顺序至关重要，**同步P操作放在互斥P操作前**。
3. 两个V操作放在一起，顺序无关紧要。