---
title: 【C++】数据类型表达与处理
author: zhugenmi
date: 2024-10-11 
categories: [C++, C++ Primer]
tags: [c++]
---

## 数据类型

整型类型（占用字节）：

```cpp
bool(1) < char(1) < signed char(1) < unsigned char(1) < short(2) < unsigned short(2) < int(4) < unsigned int(4) < long(4) < unsigned long(4) < long long(8) < unsigned long long(8)
```

浮点类型（占用位数）：`float(32) < double(64) < long double(80~120)` （`short`至少为16位，`int`至少与`short`一样长，`long`至少为32位且至少和`int`一样长）

一个内存单元占用8位（bit/比特）内存空间。

1字节（byte）=8位（bit） 1byte=8bit  1KB=1024B

## `sizeof`运算符

计算圆括号内数据类型或变量所占用内存大小（Byte）。对类型名（如`int`）使用`sizeof`运算符时，应将名称放在括号中，但对变量名（如`n_short`）使用该运算符时，括号是可选的。

| 字符 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| \t   | 水平制表符，跳到下一个tab位（`空格个数=\|n-8\|%8`, `n`为`\t`前字符占位） |
| \r   | 输出回到本行行首，并覆盖之前的输出。“`hello world!\rxxx`” 结果为 ”`xxxlo world!`” |
| \n   | 换行符                                                       |
| \v   | 垂直制表符                                                   |
| \f   | 换页                                                         |

## 常量类型

### 整数直接常量

1. 十进制整数
2. 长整数。在整数后加`L`或`l`，如`123L`、`-98l`等。
3. 无符号整数。在整数后加`U`（`u`），如`123U`、`-98u`
4. 十六进制整数。由`0 1 2 3 … D E F`组成（不分大小写）。在数值前加`0x`或`0X`，如`0X2a`、`0xFFFF`。注意： `cout`用16进制整数输出内存地址。
5. 八进制整数。在整数前加数字`0`， 如`010`为八进制数。

### 浮点数直接常量

- 小数形式。如`0.123`, `.123`, `8.0`, `8.` 等。若整数或小数为0可省略不写，如省略小数部分，小数点一定要保留，否则不是浮点数而是整数。
- 指数形式。数字和指数构成，如`1.23e3`、`0.123e4`、`123E-2`

### 字符直接常量

一对单引号括起来的一个字符，如`‘A’ ‘5’ ‘%’ ‘_’`

### 字符串直接常量

用一对双引号括起来的字符串，串的结尾有`’\0’`字符

### 符号常量

用编译器预处理命令`#define`定义的宏。在编译前，它被预处理器替换为一串字符，又称宏替换。（代码中应采用变量或常量，不要直接使用具体的数据值）

>C\C++表达式只能用圆括号（可多层嵌套）、方括号（数组）、花括号（复合类型、函数体等）。在初始化声明中，若使用关键字auto，而不是指定变量类型，编译器讲把变量的类型设置成与初始值相同。auto x = 0.0; //x为double型

### `wchar_t`类型

`wchar_t`是一种整数类型，它有足够空间，可表示系统使用的最大扩展字符集。处理 `wchar_t` 流—`wcin/wcout`.
（无符号）``char16_t ch1 = u’q’;`` //用前缀`u`表示16位`char16_t`字符（串）常量
（无符号）`char32_t ch2 = U’/U0000222B’;` //用前缀`U`表示32位`char32_t`字符（串）常量

## 数据类型转换

### 自动类型转换

化异为同，低精度类型向高精度类型转换。

整型升级：`char`和`short`  只要参与运算就自动升级为`int`，`bool`自动升级为`unsigned int`，其值为0、1；

不同类型混合运算：系统自动将不同类型先转换为同一类型，即表达式中最高精度类型。

在计算表达式时系统自动将`float`转换为`double`，浮点数值常量也是`double`。

### 强制类型转换

在待转换对象前加上类型名（如`double`，`int`），类型名两端有圆括号（C语言），也可省略（C++），待转换对象可以是表达式、变量或常量。
格式：

```cpp
(typename) value //C
Typename (value) //C++  => static_cast<typename> (value)
```

如：

```C++
float d1=2.5;
int d2=2;
int d3=int(d1*d2); //这里将表达式的结果转换为int型（5）
double d4=(int)d1*d2; //这里将d1转换为int再计算（4）
```

### 初始化和赋值进行的转换

将0赋给`bool`变量时将被转换为`false`，而非零值将被转换为`true`。

### 以`{ }`方式初始化时进行的转换

如：

```cpp
char x {66}; // 这是合法的，因为 66 在 char 的范围内
char y {300}; // 这是不合法的，编译器会报错，因为 300 超出了 char 的表示范围
```

列表初始化不允许缩窄，即变量的类型可能无法表示赋给它的值。

> 缩窄转换是指将一个较大范围的数值类型转换为一个较小范围的数值类型，这可能导致信息丢失。例如，将一个 `double` 类型的值转换为 `int` 类型时，可能会丢失小数部分，或者将一个 `int` 类型的值转换为 `char` 类型时，可能会超出 `char` 的表示范围。

### 表达式中的转换

整型级别高低 `long long > long >int >short >signed char`

### 传递参数时的转换

函数参数时的类型转换。

## 自增运算符（仅用于变量）

1. **前置自增（`++i`）**：
   - 在执行自增操作之前，变量 `i` 的值会被增加。
   - 返回的是自增后的值。
2. **后置自增（`i++`）**：
   - 在执行自增操作之后，变量 `i` 的值会被增加。
   - 返回的是自增前的值。

`++i`、`--i `：前置（前缀）操作符 `k2=++k1`等价于`k1=k1+1;k2=k1;`
`i++`、`i--` ：后置（后缀）操作符 `k2=k1++` 等价于`k2=k1;k1=k1+1;`

## 组合赋值表达式

`左端□=右端` 等价于 `左端=左端□(右端)`
  `X+=3`等价于`x=x+3`
  `M%=2`等价于`m=m%2`
  `X*=y+1`等价于`x=x*(y+1)`
逗号运算符“，”   `表达式1，表达式2，… ，表达式n` 说明：从左到右依次计算表达式1~n，将n的结果作为整个逗号表达式的结果。
eg：`a=5, b=10, c=a+b  //c=15`

## 成员函数`cout.put()`

类：`istream/ostream` 对象：`cout`
通过对象（`cout`）使用成员函数，须用句点将对象名和函数名称（`put`)连接起来；句点被称为成员运算符。即 `cout.put()`通过类对象`cout`来使用函数`put()`，它提供了另一种显示字符的方法，可替代`<<`运算符。

