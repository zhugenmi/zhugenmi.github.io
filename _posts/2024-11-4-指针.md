---
title: 指针
author: zhugenmi
date: 2024-11-4 15:20 +0800
categories: [C/C++, C语言编程]
tags: [c]
description: 
---

## 指针概述

每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（`&`）运算符访问的地址，它表示了在内存中的一个地址。

指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：

```c
type *var_name;
```

`type` 是指针的基类型，它必须是一个有效的数据类型，`var_name` 是指针变量的名称。

实际上，所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，**都是一个代表内存地址的长的十六进制数**。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。

使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 `* `返回操作数所指定地址变量的值，例如：

```c
int var = 20; /* 实际变量的声明 */
int *ip; /* 指针变量的声明 */
ip = &var; /* 在指针变量中存储 var 的地址 */
printf("Address of var variable: %x\n", &var );/* 在指针变量中存储的地址 */
printf("Address stored in ip variable: %x\n", ip );/* 使用指针访问值 */
printf("Value of *ip variable: %d\n", *ip );
```

**在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯**。赋为 `NULL `值的指针被称为空指针。

如需检查一个空指针，可以使用 `if` 语句：

```c
if(ptr) 
//或者
if(!ptr)
```

可以对指针进行四种算术运算：++、--、+、-。

假设 `ptr` 是一个指向地址 1000 的整型指针，是一个 32 位的整数，则执行`ptr++`后`ptr`将指向位置1004，因为 `ptr` 每增加一次，它都将指向下一个整数位置。

在C语言编程中，经常在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，因为数组是一个常量指针。同样地，对指针进行递减运算，即把值减去其数据类型的字节数。

如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。指针可以用关系运算符进行比较，如 `==`、`<` 和 `>`。

示例，下面的程序中，只要变量指针所指向的地址小于或等于数组的最后一个元素的地址 `&var[MAX - 1]`，则把变量指针进行递增：：

```c
#include <stdio.h>
const int MAX = 3;
int main ()
{
	int var[] = {10, 100, 200};
	int i, *ptr;
	/* 指针中第一个元素的地址 */
	ptr = var;
	i = 0;
	while ( ptr <= &var[MAX - 1] )
	{
		printf("Address of var[%d] = %x\n", i, ptr );
		printf("Value of var[%d] = %d\n", i, *ptr );
		/* 指向上一个位置 */
		ptr++;
		i++;
	}
	return 0;
}
```

运行结果：

```bash
Address of var[0] = bfdbcb20
Value of var[0] = 10
Address of var[1] = bfdbcb24
Value of var[1] = 100
Address of var[2] = bfdbcb28
Value of var[2] = 200
```

实例：计算字符串长度

```c
int my_strlen(char *p)
{
	char *old=p;
	while(*p!='\0')p++;
	return p-old;
}
```

通过指针的差值得出字符串的长度。

## 指针数组

在某些情况下，想要让数组存储指向 int 或 char 或其他数据类型的指针。下面是一个指向整数的指针数组的声明：

```c
int *ptr[MAX];
```

`ptr`中的每个元素都是一个指向`int`值的指针。

例如：

```c
int var[] = {10, 100, 200};
int i, *ptr[MAX];
for ( i = 0; i < MAX; i++)
{
	ptr[i] = &var[i]; /* 赋值为整数的地址 */
}
for ( i = 0; i < MAX; i++)
{
	printf("Value of var[%d] = %d\n", i, *ptr[i] );
}
```

## C语言数组指针（指向数组的指针）

访问数组元素的两种方式：

- 使用下标
  也就是采用 `arr[i]` 的形式访问数组元素。如果 `p` 是指向数组 `arr` 的指针，那么也可以使用 `p[i]` 来访问数组元素，它等价于 `arr[i]`。

- 使用指针

  也就是使用 `*(p+i)` 的形式访问数组元素。另外数组名本身也是指针，也可以使用 `*(arr+i)` 来访问数组元素，它等价于 `*(p+i)`。

遍历数组元素实例：

```c
#include <stdio.h>
int main(){
	int arr[] = { 99, 15, 100, 888, 252 };
	int i, *p = arr, len = sizeof(arr) / sizeof(int);
	for(i=0; i<len; i++){
        //以指针方式遍历数组元素
        printf("%d ", *(arr+i) ); //*(arr+i)等价于arr[i]
        
        //以数组指针遍历数组元素
		printf("%d ", *(p+i) );
        
        //借助自增运算符来遍历数组元素
        printf("%d ", *p++ );
	}
	printf("\n");
	return 0;
}
```

> 数组在内存中只是数组元素的简单排列，没有开始和结束标志，在求数组的长度时不能使用`sizeof(p) / sizeof(int)`，因为 p 只是一个指向 int 类型的指针，编译器并不知道它指向的到底是一个整数还是一系列整数（数组），所以 `sizeof(p) `求得的是 p 这个指针变量本身所占用的字节数，而不是整个数组占用的字节数。

第 13 行代码中，`*p++` 应该理解为` *(p++)`，每次循环都会改变 `p` 的值（`p++` 使得 `p` 自身的值增加），以使 `p` 指向下一个数组元素。该语句不能写为 `*arr++`，因为 `arr` 是常量，而 `arr++` 会改变它的值，这显然是错误的。

假设 `p` 是指向数组 `arr `中第 n 个元素的指针，那么` *p++`、`*++p`、`(*p)++` 分别是什么意思呢？

`*p++` 等价于 `*(p++)`，表示先取得第 n 个元素的值，再将 `p` 指向下一个元素，上面已经进行了详细讲解。

`*++p` 等价于` *(++p)`，会先进行 `++p` 运算，使得 `p` 的值增加，指向下一个元素，整体上相当于 `*(p+1)`，所以会获得第 n+1 个数组元素的值。

`(*p)++` 就非常简单了，会先取得第 n 个元素的值，再对该元素的值加 1。假设 `p` 指向第 0 个元素，并且第 0 个元素的值为 99，执行完该语句后，第 0 个元素的值就会变为 100。

## C语言字符串指针（指向字符串的指针）

字符数组归根结底还是一个数组，上面讲到的关于指针和数组的规则同样也适用于字符数组。

使用指针输出字符串的三种方式：

```c
char str[] = "1234567890";
char *pstr = str;
int len = strlen(str), i;

//使用*(pstr+i)
for(i=0; i<len; i++){
	printf("%c", *(pstr+i));
}
printf("\n");

//使用pstr[i]
for(i=0; i<len; i++){
	printf("%c", pstr[i]);
}
printf("\n");

//使用*(str+i)
for(i=0; i<len; i++){
	printf("%c", *(str+i));
}
printf("\n");
```

除了字符数组，C语言还支持另外一种表示字符串的方法，就是直接使用一个指针指向字符串。例如：

```c
char *str = "123456789";
```

或者：

```c
char *str;
str = "123456789";
```

字符串中的所有字符在内存中是连续排列的，`str `指向的是字符串的第 0 个字符；我们通常将第0个字符的地址称为字符串的首地址。字符串中每个字符的类型都是`char`，所以 str `的`类型也必须是`char *`。

```c
//直接输出字符串
printf("%s\n", str);
```

字符串和字符数组都可以使用`%s`输出整个字符串，都可以使用`*`或`[ ]`获取单个字符。它们最根本的区别是在内存中的存储区域不一样，**字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区**。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限。

内存权限的不同导致的一个明显结果就是，字符数组在定义后可以读取和修改每个字符，而对于第二种形式的字符串，一旦被定义后就只能读取不能修改，任何对它的赋值都是错误的。所以，将第二种形式的字符串称为字符串常量。

```c
#include <stdio.h>
int main(){
	char *str = "Hello World!";
	str = "I love C!"; //正确，可以更改指针变量本身的指向
	str[3] = 'P'; //错误，不能修改字符串中的字符
	return 0;
}
```

> 在编程过程中如果只涉及到对字符串的读取，那么字符数组和字符串常量都能够满足要求；如果有写入（修改）操作，那么只能使用字符数组，不能使用字符串常量。

最后我们来总结一下，C语言有两种表示字符串的方法，一种是字符数组，另一种是字符串常量，它们在内存中的存储位置不同，使得字符数组可以读取和修改，而字符串常量只能读取不能修改。

## 指向指针的指针

指向指针的指针是一种**多级间接寻址**的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。

一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。

```c
#include <stdio.h>
int main ()
{
	int var;
	int *ptr;
	int **pptr;
    
	var = 3000;
    
	/* 获取var 的地址 */
	ptr = &var;
    
	/* 使用运算符 & 获取 ptr 的地址 */
	pptr = &ptr;
    
    /* 使用 pptr 获取值 */
	printf("Value of var = %d\n", var );
	printf("Value available at *ptr = %d\n", *ptr );
	printf("Value available at **pptr = %d\n", **pptr);
	return 0;
}
```

运行结果：

```bash
Value of var = 3000
Value available at *ptr = 3000
Value available at **pptr = 3000
```

## 传递指针给函数

C 语言允许传递指针给函数，只需要简单地声明函数参数为指针类型即可。

```c
void getSeconds(unsigned long *par)
{
	/* 获取当前的秒数 */
	*par = time( NULL );
	return;
}

...in main function
	unsigned long sec;
	getSeconds( &sec );
...
```

能接受指针作为参数的函数，也能接受数组作为参数。

```c
double getAverage(int *arr, int size)
{
	int i, sum = 0;
	double avg;
	for (i = 0; i < size; ++i)
	{
		sum += arr[i];
	}
	avg = (double)sum / size;
	return avg;
}
```

## 从函数返回指针

C 允许从函数返回指针，这时需要声明一个返回指针的函数：

```c
int * myFunction()
{
}
```

再次注意，C 不支持在函数外返回局部变量的地址，除非定义局部变量为 `static` 变量。

## C语言函数指针（指向函数的指针）

一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。我们可以把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指针。

函数指针的定义形式为：

```c
returnType (*pointerName)(param list);
```

`returnType `为函数返回值类型，`pointerNmae `为指针名称，`param list` 为函数参数列表。参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称，这一点和函数原型非常类似。

> 注意`( )`的优先级高于`*`，第一个括号不能省略，如果写作`returnType *pointerName(param list);`就成了函数原型，它表明函数的返回值类型为`returnType *`。

示例 ：

```c
#include <stdio.h>
//返回两个数中较大的一个
int max(int a, int b){
	return a>b ? a : b;
}
int main(){
	int x, y, maxval;
	//定义函数指针
	int (*pmax)(int, int) = max; //也可以写作int (*pmax)(int a, int b)
	printf("Input two numbers:");
	scanf("%d %d", &x, &y);
	maxval = (*pmax)(x, y);
	printf("Max value: %d\n", maxval);
	return 0;
}
```

使用`typedef`定义函数指针:

```c
typedef void *(*func)(int a,int b);
```

执行以上代码之后，`func`就表示函数指针的类型。可以使用`func`去声明新的函数指针。

例如：`func func_data;`

### 指针总结

指针（Pointer）就是内存的地址，C语言允许用一个变量来存放指针，这种变量称为指针变量。指针变量可以存放基本类型数据的地址，也可以存放数组、函数以及其他指针变量的地址。

程序在运行过程中需要的是数据和指令的地址，变量名、函数名、字符串名和数组名在本质上是一样的，它们都是地址的助记符：在编写代码的过程中，我们认为变量名表示的是数据本身，而函数名、字符串名和数组名表示的是代码块或数据块的首地址；程序被编译和链接后，这些名字都会消失，取而代之的是它们对应的地址。

常见的指针变量的定义：

| 定 义        | 含 义                                                        |
| ------------ | ------------------------------------------------------------ |
| int *p;      | p 可以指向 `int `类型的数据，也可以指向类似 `int arr[n]` 的数组。 |
| int **p;     | p 为二级指针，指向 `int *` 类型的数据。                      |
| int *p[n];   | p 为指针数组。`[ ]` 的优先级高于 `*`，所以应该理解为 `int *(p[n])`; |
| int (*p)[n]; | p 为二维数组指针。                                           |
| int *p();    | p 是一个函数，它的返回值类型为 `int *`。                     |
| int (*p)();  | p 是一个函数指针，指向原型为 `int func()` 的函数。           |

1) 指针变量可以进行加减运算，例如`p++`、`p+i`、`p-=i`。指针变量的加减运算并不是简单的加上或减去一个整数，而是跟指针指向的数据类型有关。
2) 给指针变量赋值时，要将一份数据的地址赋给它，不能直接赋给一个整数，例如`int *p = 1000;`是没有意义的，使用过程中一般会导致程序崩溃。
3) **使用指针变量之前一定要初始化**，否则就不能确定指针指向哪里，如果它指向的内存没有使用权限，程序就崩溃了。对于暂时没有指向的指针，建议赋值`NULL`。
4) 两个指针变量可以相减。如果两个指针变量指向同一个数组中的某个元素，那么相减的结果就是两个指针之间相差的元素个数。
5) 数组也是有类型的，数组名的本意是表示一组类型相同的数据。在定义数组时，或者和 `sizeof`、`&` 运算符一起使用时数组名才表示整个数组，表达式中的数组名会被转换为一个指向数组的指针。