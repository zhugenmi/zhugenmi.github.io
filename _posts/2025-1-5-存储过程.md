---
title: 存储过程
author: zhugenmi
date: 2025-1-5 10:00 +0800
categories: [数据库原理与应用,SQL Server]
tags: [sqlserver]
description: 
---

# 存储过程/函数：procedure/function

通俗说，存储过程是个模块化的程序段，完成一定功能，可被反复调用，可用于解决复杂的问题，减少程序冗余度。

这里的过程和函数就是C语言的方法/函数。过程一般不直接返回值，但可以通过实参和形参返回给主调程序计算结果；函数在SQLSERVER中，它都要返回一个值。（统一看，C语言中的返回void的函数在这里叫过程，有返回类型值的函数在这里叫函数）

# 程序的流程

## 变量的定义

```sql
Declare @变量名 类型[(宽度),类型…..]
```

 为了区分系统内存变量（包括表的列名和系统环境参数）和用户自定义变量，要求用户自定义变量时前加``@``符号。当打开一个表时，表的所有列名如学号，姓名是变量，控制系统内部的参数设置的量也是变量-----系统变量和列变量。

如要定义一个自定义变量保存杨春同学学号:

```sql
declare @xh nchar(10)
select @xh=学号 from 学生表 where 姓名='杨春'
print @xh
```

为什么要用``@xh``，而不是``xh``，因为表列名有可能是“``xh``”，这是为了避免冲突误会。修改上面程序段，也正确：

```sql
declare @学号 nchar(10)
select @学号=学号 from 学生表 where 姓名='杨春'
print @学号
```

## 赋值

```sql
Set @变量名=值/表达式
Select @变量名=值/表达式 from 表…..
```

例：定义变量存放性别和姓氏，把这些变量代入查询语句并输出结果

```sql
declare @xs nchar(1),@xb nchar(1)
 set @xs='李'
 set @xb='男'
 select * from 学生表 where left(姓名,1)=@xs and 性别=@xb
```

例：如果在C#/java中如何拼凑这个查询命令？ 字符串和日期常量数据都要加单引号，数值型不加

```c#
String s=”select * from 学生表 where left(姓名,1)=’”+xs+”’  and 性别=’”+xb+”’ and 身高>”+sg;
```

利用上例的数据，S的结果：

```sql
”select * from 学生表 where left(姓名,1)=’李’ and 性别=’男’ and 身高>175”
```

# 分支结构

## if else 

 格式：只能用在过程或函数中，不能嵌套到其它sql命令中。

```sql
If(条件)
 Begin
  成立时语句序列
 End
Else
 Begin
  条件不成立时的语句序列
 End
```

`begin …end `，等效于C语句中``{ }``； 当语句序列退化成一句时，这个``begin…end``是可以省写的。

例：根据姓名(``@xm``变量)查询此人101课程的成绩值，再根据本成绩值判断等级，[80，100]为优秀，[60，80）为合格，60以下为不合格.

```sql
declare @xm nchar(10),@cj int,@dj nchar(3)
set @xm='李大方'

select @cj=成绩 from 成绩表 where 课程号='101' and 学号=(select 学号 from 学生表 where 姓名=@xm)

if(@cj is null)
 begin
  set @dj='没选课'
 end
else
 begin
  if(@cj>=80) set @dj='优秀'
  else if(@cj>=60) set @dj='合格'
  else set @dj='不合格'
 end 
 
print Rtrim(@xm)+'同学的课程成绩为:'+convert(nchar(3),@cj)+',等级为:'+@dj
```

## case when

`case when` 用法（直接多分支，类似于switch功能，但它不是独立的命令语句）

 格式1：

```sql
 Case 表达式
  When 常量1 then 结果1
  When 常量2 then 结果2
  …
  When 常量n then 结果n
  Else  结果n+1
End  
```

与``switch``不大一样的是：每个``then`` 后面的结果不需要加``break``;本系统只执行一个条件，不会从条件入口进来后，还要往下执行

例：把数据库中读出来星期数值（0-6表示星期天—星期六）

```sql
declare @xq smallint,@xqre nchar(3)

set @xq=15

select @xqre=
case @xq
 when 0 then '星期日'
 when 1 then '星期一'
 when 2 then '星期二'
 when 3 then '星期三'
 when 4 then '星期四'
 when 5 then '星期五'
 when 6 then '星期六'
 else  '无效值'
end

print @xqre
```

格式2： 用法比格式1要灵活得多

```sql
Case 
  When 条件1 then 结果1
  When 条件2 then 结果2
 …..
  When 条件n then 结果n
  Else 结果n+1
End 
```

如：

```sql
declare @xq smallint,@xqre nchar(3)

set @xq=1

select @xqre=
case 
 when @xq=0 then '星期日'
 when @xq=1 then '星期一'
 when @xq=2 then '星期二'
 when @xq=3 then '星期三'
 when @xq=4 then '星期四'
 when @xq=5 then '星期五'
 when @xq=6 then '星期六'
 else  '无效值'
end

print @xqre
```

例：用格式2解决上面成线等级问题(比if写法直接，易读易懂)

```sql
declare @xm nchar(10),@cj int,@dj nchar(3)
set @xm='李大方'

select @cj=成绩 from 成绩表 where 课程号='101' and 学号=(select 学号 from 学生表 where 姓名=@xm)

select @dj=
case 
 when @cj>=80 and @cj<=100 then '优秀'
 when @cj>=60 then '合格'
 when @cj>=0 then '不合格'
 else '无效值'
end

print Rtrim(@xm)+'同学的课程成绩为:'+convert(nchar(3),@cj)+',等级为:'+@dj
```

如``@cj``为85，满足了``@cj>60  @cj>=0``，与c不同的是，只会从上向下找到第一个满足条件来执行，后面即使再有满足条件的情况也不执行，跳到``end``后。

例：查出李大方的101课程成绩情况，列出数据：学号，姓名，课程名，成绩，实得学分

```sql
declare @xh char(10),@xm nchar(6),@kcm nchar(10),@cj int,@sdxf int

select @xh=a.学号,@xm=姓名,@kcm=名称,@cj=成绩,
 @sdxf=学分 from 学生表 a join 成绩表 b on a.学号=b.学号 
  join 课程表 c on b.课程号=c.课程号
 if(@cj<60)
  set @sdxf=0
  
select @xh,@xm,@kcm,@cj,@sdxf
```

再例：查出李大方和李四方的101和102两门课程成绩情况，列出数据： 学号，姓名，课程名，成绩，实得学分

```sql
select a.学号,姓名,名称,成绩,
  case 
  when 成绩>=60 then 学分
  else 0
  end as  实得学分
from 学生表 a join 成绩表 b on a.学号=b.学号 join 课程表 c on b.课程号=c.课程号 where 姓名 in('李大方','李四方') and c.课程号 in('101','102')
```

例：身高在1.70以上为高，否则为矮；把表中表示是否党员的1、0转换为“党员”，“群众”；把籍贯值前含有四川，成都字样的人列出数据： 学号，姓名，身高，身高标准，党员否

```sql
select 学号,姓名,身高,
  case when 身高>=1.7 then '高' else '矮' end as 身高标准, 
  case when 团员否=1 then '学员' else'非党员' end as 党员否 
  from 学生表 where 家庭住址 like '四川%' or 家庭住址 like '成都%'
```

# 循环

格式：

```sql
While(条件)
 Begin
  循环体语句序列
 End
```

在这里循环使用较少，因为数据库的查询 select本身就是从首行自动循环到尾行。

例：输入一个n求 s=1+2+3+…n

```sql
declare @n int,@s int,@i int

set @n=100
set @s=0
set @i=1

while(@i<=@n)
begin
 set @s=@s+@i
 set @i=@i+1
end

print @s
```

# 存储过程应用

 过程体语句(可是若干条命令)：

```sql
 create procedure 过程名 as 
```

 类似老的C：``void 函数名( ) { 函数体}``

 过程本身不通过过程名带回来计算结果，所以类似于``void``（并不是通过形参的改变返回数据给实参）

## 无参传递过程

主调程序不需要传递实参给过程。

例：调用过程查询杨春的数据。

```sql
 create procedure p1 as 
 declare @xm nchar(6)
 set @xm='杨春'
 select 学号,姓名,生日 from 学生表 where 姓名=@xm
```

 完成过程的建立，然后在其它主调程序中调用：``exec 过程名``

```sql
 execute p1
```

## 有参传递过程

实用性强，通用性好。

例：输入一个姓名，课程号 ,调用过程查询该人该科成绩值

```sql
create procedure p2 @xm nchar(6),@kch nchar(3)
as 
 select 成绩 from 成绩表 where 课程号=@kch and 学号 in(select 学号 from 学生表 where 姓名=@xm)
 
 execute p2 '李大方','101'
```

以上两例无返回值，在过程本身内部把结果显示出来而已，并不是把计算结果返回给调用处。

## 有参数，且把计算结果返回给调用处

例：修改上例，把计算得到成绩值结果返回给调用处

分析：过程不返回值，但可以通过形参把结果返回给过程的实参（要多定义专用变量返回结果-----类似于C++中的引用调用，传地址调用）

 ```sql
create procedure p3 @xm nchar(6),@kch nchar(3),@cj int output
as 
 declare @cj0 int
 select @cj0=成绩 from 成绩表 where 课程号=@kch and
  学号 in(select 学号 from 学生表 where 姓名=@xm)
 set @cj=@cj0
 ```

调用

```sql
 declare @cj int 
 execute p3 '李大方','101',@cj output
 print @cj
```

说明：需要返回值的实参和形参后面都要跟上``output``.掌握此概念后，调用一个过程随便返回什么数据，随便返回多少个数据。

可见：**过程就是一个小功能模板，程序段，一般是参数的输入，输出，与外界进行接口。**

完善上例：

```sql
create procedure p3 
 @xm nchar(6),@kch nchar(3),@cj int output,@err nchar(10) output
as 
 declare @cj0 int
 set @err=''
 select @cj0=成绩 from 成绩表 where 课程号=@kch and
  学号 in(select 学号 from 学生表 where 姓名=@xm)
 if(@cj0 is null) set @err='姓名或课程号错误'
 set @cj=@cj0
```

调用

```sql
 declare @cj int ,@err nchar(10)
 execute p3 '李大方','101',@cj output,@err output
 print @cj
 print @err
```

