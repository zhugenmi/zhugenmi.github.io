---
title:  机器级表示（ATT汇编语言）
author: zhugenmi
date: 2024-11-18 22:00 +0800
categories: [Systematic Capacity]
tags: [asm]
description: 
---
## 机器级表示（ATT汇编语言）

AT&T是运营贝尔实验室多年的公司，ATT格式的汇编代码，是GCC、OBJDUMP和其他一些工具的默认格式。而其他一些编程工具，包括Microsoft的工具，以及来自Intel的文档，其汇编代码都是Intel格式的。

术语“字（word）”表示16位数据类型，32位数为“双字（double words）"，64位数为”四字（quad words）“。

C语言数据类型在 x86_64 中的大小。在64位机器中，指针长8字节。

| C声明  | Intel数据类型 | 汇编代码后缀 | 大小（字节） |
| ------ | ------------- | ------------ | ------------ |
| char   | 字节          | b            | 1            |
| short  | 字            | w            | 2            |
| int    | 双字          | l            | 4            |
| long   | 四字          | q            | 8            |
| char * | 四字          | q            | 8            |
| float  | 单精度        | s            | 4            |
| double | 双精度        | l            | 8            |

### 整数寄存器

一个 x86_64 的中央处理单元（CPU）包含一组16个存储64位值的**通用目的寄存器**，用来存储整数数据和指针。所有16个寄存器的低位部分都可以作为字节、字（16位）、双字（32位）和四字（64位）数字来访问。

| 64位（四字） | 32位（双字） | 16位（字） | 8位（字节） | 说明         |
| ------------ | ------------ | ---------- | ----------- | ------------ |
| %rax         | %eax         | %ax        | %al         | 返回值       |
| %rbx         | %ebx         | %bx        | %bl         | 被调用者保存 |
| %rcx         | %ecx         | %cx        | %cl         | 第4个参数    |
| %rdx         | %edx         | %dx        | %dl         | 第3个参数    |
| %rsi         | %esi         | %si        | %sil        | 第2个参数    |
| %rdi         | %edi         | %di        | %dil        | 第1个参数    |
| %rbp         | %ebp         | %bp        | %bpl        | 被调用者保存 |
| %rsp         | %esp         | %sp        | %spl        | 栈指针       |
| %r8          | %r8d         | %r8w       | %r8b        | 第5个参数    |
| %r9          | %r9d         | %r9w       | %r9b        | 第6个参数    |
| %r10         | %r10d        | %r10w      | %r10b       | 调用者保存   |
| %r11         | %r11d        | %r11w      | %r11b       | 调用者保存   |
| %r12         | %r12d        | %r12w      | %r12b       | 被调用者保存 |
| %r13         | %r13d        | %r13w      | %r13b       | 被调用者保存 |
| %r14         | %r14d        | %r14w      | %r14b       | 被调用者保存 |
| %r15         | %r15d        | %r15w      | %r15b       | 被调用者保存 |

### 操作数格式

大多数指令有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。各种不同的操作数的可能性被分为三种类型：第一种类型是立即数，用来表示常数值；第二种类型是寄存器，表示某个寄存器的内容，用符号$r_a$来表示任意寄存器$a$，用引用$R[r_a]$来表示它的值；第三类操作数是内存引用，根据计算出来的地址（通常称为有效地址）访问某个内存位置。

操作数可以表示立即数（常数）值、寄存器值或是来自内存的值。比例因子$s$必须是1/2/4/8。

| 类型   | 格式         | 操作数值             | 名称                |
| ------ | ------------ | -------------------- | ------------------- |
| 立即数 | $Imm         | Imm                  | 立即数寻址          |
| 寄存器 | ra           | R[ra]                | 寄存器寻址          |
| 存储器 | Imm          | M[Imm]               | 绝对寻址            |
| 存储器 | (ra)         | M[R[ra]]             | 间接寻址            |
| 存储器 | Imm(rb)      | M[Imm+R[rb]]         | （基址+偏移量）寻址 |
| 存储器 | (rb,ri)      | M[R[rb]+R[ri]]       | 变址寻址            |
| 存储器 | Imm(rb,ri)   | M[Imm+R[rb]+R[ri]]   | 变址寻址            |
| 存储器 | (,ri,s)      | M[R[ri]⋅s]           | 比例变址寻址        |
| 存储器 | Imm(,ri,s)   | M[Imm+R[ri]⋅s]       | 比例变址寻址        |
| 存储器 | (rb,ri,s)    | M[R[rb]+R[ri]⋅s]     | 比例变址寻址        |
| 存储器 | Imm(rb,ri,s) | M[Imm+R[rb]+R[ri]⋅s] | 比例变址寻址        |

### 数据传送指令

#### 简单数据传送指令

MOV类由四条指令组成：`movb`、`movw`、`movl`和`movq`，这些指令把数据从源位置复制到目的位置，区别在于它们操作的数据大小不同，分别是1、2、4和8字节。 

| 指令              | 效果  | 描述           |
| ----------------- | ----- | -------------- |
| MOV          S, D | D ← S | 传送           |
| movb              |       | 传送字节       |
| movw              |       | 传送字         |
| movl              |       | 传送双字       |
| movq              |       | 传送四字       |
| movabsq   I, R    | R ← I | 传送绝对的四字 |

#### 零扩展数据传送指令

这些指令以寄存器或内存地址作为源，以寄存器作为目的

| 指令            | 效果            | 描述                         |
| --------------- | --------------- | ---------------------------- |
| MOVZ       S, R | R ← 零扩展（S） | 以零扩展进行传送             |
| movzbw          |                 | 将做了零扩展的字节传送到字   |
| movzbl          |                 | 将做了零扩展的字节传送到双字 |
| movzwl          |                 | 将做了零扩展的字传送到双字   |
| movzbq          |                 | 将做了零扩展的字节传送到四字 |
| movzwq          |                 | 将做了零扩展的字传送到四字   |

#### 符号扩展数据传送指令

`MOVS `指令以寄存器或内存地址作为源，以寄存器作为目的。`cltq `指令只作用于寄存器 `%eax` 和 `%rax`

| 指令             | 效果                    | 描述                           |
| ---------------- | ----------------------- | ------------------------------ |
| MOVS        S, R | R ← 符号扩展（S）       | 传送符号扩展的字节             |
| movsbw           |                         | 将做了符号扩展的字节传送到字   |
| movsbl           |                         | 将做了符号扩展的字节传送到双字 |
| movswl           |                         | 将做了符号扩展的字传送到双字   |
| movsbq           |                         | 将做了符号扩展的字节传送到四字 |
| movswq           |                         | 将做了符号扩展的字传送到四字   |
| movslq           |                         | 将做了符号扩展的双字传送到四字 |
| cltq             | %rax ← 符号扩展（%eax） | 把 %eax 符号扩展到 %rax        |

### 入栈和出栈

在 x86_64 中，程序栈存放在内存中某个区域，栈向下增长，栈顶元素的地址（栈指针`%rsp`）是所有栈中元素地址中最低的。入栈和出栈指令：

| 指令    | 效果                                 | 描述         |
| ------- | ------------------------------------ | ------------ |
| pushq S | R[%rsp]←R[%rsp]-8;<br />M[R[%rsp]]←S | 将四字压入栈 |
| popq D  | D←M[R[%rsp]];<br />R[%rsp]←R[%rsp]+8 | 将四字弹出栈 |

### 整数算术操作

加载有效地址（leaq）指令通常用来执行简单的算术操作。其余的指令是更加标准的一元或二元操作。用$>>_A$和$>>_L$来分别表示算术右移和逻辑右移。

| 指令      | 效果        | 描述            |
| --------- | ----------- | --------------- |
| leaq S, D | D← &S       | 加载有效地址    |
| INC D     | D← D + 1    | 加1             |
| DEC D     | D← D - 1    | 减1             |
| NEG D     | D← -D       | 取负            |
| NOT D     | D← ~D       | 取补            |
| ADD S, D  | D← D + S    | 加              |
| SUB S, D  | D← D - S    | 减              |
| IMUL S, D | D← D * S    | 乘              |
| XOR S, D  | D← D ^ S    | 异或            |
| OR S, D   | D← D \| S   | 或              |
| AND S, D  | D← D & S    | 与              |
| SAL k, D  | D← D<<k     | 左移            |
| SHL k, D  | D← D<<k     | 左移（等同SAL） |
| SAR k, D  | D← D$>>_A$k | 算术右移        |
| SHR k, D  | D← D$>>_L$k | 逻辑右移        |

除了整数寄存器，CPU还维护着一组单个位的条件码寄存器，它们描述了最近的算术或逻辑操作的属性，可以检测这些寄存器来执行条件分支指令。最常用的条件码有：

- CF：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。
- ZF：零标志。最近的操作得出的结果为0。
- SF：符号标志。最近的操作得到的结果为负数。
- OF：溢出标志。最近的操作导致一个补码正溢出或负溢出。

### 比较和测试指令

这些指令不修改任何寄存器的值，只设置条件码。`CMP`指令根据两个操作数之差来设置条件码；`TEST`指令的行为与`AND`指令一样，除了它们只设置条件码而不改变目的寄存器的值。典型的用法是，两个操作数是一样的（例如，`testq %rax,%rax`用来检查`%rax`是负数、零、还是正数），或其中的一个操作数是一个掩码，用来指示哪些位应该被测试。

| 指令            | 基于      | 描述     |
| --------------- | --------- | -------- |
| **CMP S1, S2**  | **S2-S1** | **比较** |
| cmpb            |           | 比较字节 |
| cmpw            |           | 比较字   |
| cmpl            |           | 比较双字 |
| cmpq            |           | 比较四字 |
| **TEST S1, S2** | **S1&S2** | **测试** |
| testb           |           | 测试字节 |
| testw           |           | 测试字   |
| testl           |           | 测试双字 |
| testq           |           | 测试四字 |

### jump 指令

指令`jmp *%rax`用寄存器`%rax`中的值作为跳转目标，而指令`jmp *(%rax)`以`%rax`中的值作为读地址，从内存中读出跳转目标。

`jump`指令。当跳转条件满足时，这些指令会跳转到一条带标号的目的地。

| 指令         | 同义名 | 跳转条件       | 描述                   |
| ------------ | ------ | -------------- | ---------------------- |
| jmp Label    |        | 1              | 直接跳转               |
| jmp *Operand |        | 1              | 间接跳转               |
| je Lable     | jz     | ZF             | 相等/零                |
| jne Lable    | jnz    | ~ZF            | 不相等/非零            |
| js Lable     |        | SF             | 负数                   |
| jns Lable    |        | ~SF            | 非负数                 |
| jg Lable     | jnle   | \~(SF^OF)&\~ZF | 大于（有符号>）        |
| jge Lable    | jnl    | ~(SF^OF)       | 大于或等于（有符号>=） |
| jl Lable     | jnge   | SF^OF          | 小于（有符号<）        |
| jle Lable    | jng    | (SF^OF) \| ZF  | 小于或等于（有符号<=） |
| ja Lable     | jnbe   | \~CF&\~ZF      | 超过（无符号>）        |
| jae Lable    | jnb    | ~CF            | 超过或相等（无符号>=） |
| jb Lable     | jnae   | CF             | 低于（无符号<）        |
| jbe Lable    | jna    | CF \| ZF       | 低于或相等（无符号<=） |

### 条件传送指令

当传送条件满足时，指令把源值S复制到目的R。

| 指令        | 同义名  | 跳转条件       | 描述                   |
| ----------- | ------- | -------------- | ---------------------- |
| cmove S, R  | cmovz   | ZF             | 相等/零                |
| cmovne S, R | cmovnz  | ~ZF            | 不相等/非零            |
| cmovs S, R  |         | SF             | 负数                   |
| cmovns S, R |         | ~SF            | 非负数                 |
| cmovg S, R  | cmovnle | \~(SF^OF)&\~ZF | 大于（有符号>）        |
| cmovge S, R | cmovnl  | ~(SF^OF)       | 大于或等于（有符号>=） |
| cmovl S, R  | cmovnge | SF^OF          | 小于（有符号<）        |
| cmovle S, R | cmovng  | (SF^OF) \| ZF  | 小于或等于（有符号<=） |
| cmova S, R  | cmovnbe | \~CF&\~ZF      | 超过（无符号>）        |
| cmovae S, R | cmovnb  | ~CF            | 超过或相等（无符号>=） |
| cmovb       | cmovnae | CF             | 低于（无符号<）        |
| cmovbe      | cmovna  | CF \| ZF       | 低于或相等（无符号<=） |

### 通过寄存器传递函数参数

x86_64 中，可以通过寄存器最多传递6个整型（即整数和指针）参数，如果一个函数有大于6个整型参数，超出6个的部分就要通过栈来传递。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小，会根据参数在参数列表中的顺序为它们分配寄存器。可以通过64位寄存器适当的部分访问小于64位的参数。例如，若第一个参数是32位的，那么可以用`%edi`来访问它。

| 操作数大小（位） | 参数1 | 参数2 | 参数3 | 参数4 | 参数5 | 参数6 |
| ---------------- | ----- | ----- | ----- | ----- | ----- | ----- |
| 64               | %rdi  | %rsi  | %rdx  | %rcx  | %r8   | %r9   |
| 32               | %edi  | %esi  | %edx  | %ecx  | %r8d  | %r9d  |
| 16               | %di   | %si   | %dx   | %cx   | %r8w  | %r9w  |
| 8                | %dil  | %sil  | %dl   | %cl   | %r8b  | %r9b  |