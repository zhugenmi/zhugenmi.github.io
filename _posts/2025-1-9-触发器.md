---
title: 触发器
author: zhugenmi
date: 2025-1-9 10:00 +0800
categories: [数据库原理与应用,SQL Server]
tags: [sqlserver]
description: 
---

# 概念

触发器是一种特殊的存储过程，是发生在用户对数据进行增，删，改时自动运行的一个过程。是一种程序方式的对数据完整性控制的补充，操作更加灵活，它进一步保证数据在业务逻辑的正确性。

数据在非查询的修改时，临时表问题(只能在触发器的代码中使用)

（1）inserted表：用户向表插入新记录数据时，（A步）先插入在系统的一个临时表inserted表（B步）中，再从inserted表中插入到物理数据库表中(C步)。在上面的BC步之间，还要以做一些判断，判断逻辑正确后，再完成C步。在BC中执行一些判断数据逻辑正确的代码就是触发器概念。如，判断inserted临时表的数据不符合业务逻辑需要，则取消它的C步。

（2）deleted表：要从物理表删除记录，并不是一次性直接删除，而是先从物理表把要删除的记录存放到临时表deleted中，在这个临时表中再判断业务逻辑是否正确，如果真的要删，则才在真正的物理删除它。

无专业的updated临时表，要更新一个记录，把要更新的数据存放在inserted临时表中，确保无误后，再删除原记录，再在原位置插入新记录.(删除记录，更新记录，都要用于deleted临时表。更新记录时要同时使用deleted和inserted临时表. 这两个临时表，是系统自动根据被操作的物理表的表头结构建立的。          

# 建立触发器的格式

 ```sql
Create trigger 触发器名 on 表名/视图名 For after/instead of Insert/delete/update
As Sql语句序列
 ```

针对一个物理表可以建立多个触发器,但针对增/删除/改同一种操作上一般只建立一个触发器，一般触发器是建立在对数据（表、视图）增，删，改时发生，不针对数据库及非表的其它对象操作。

# 后触发器: for after 

 先完成增/删/改操作后，后再执行触发器判断。

过程：遇到了insert,delete,update时先操作这些语句命令（前提是不会违反以前建立数据表时各种线束），再执行解发器。

 数据操作已经完成了，再执行触发器，如果在触发器执行过程中，发现数据业务逻辑不正确，系统会自动反向操作上一句（撤销上一步的更改操作）

例：针对学生表建立一个after后触发器trigsex，当插入或修改学生表性别值时，检查数据是否为男或女。

```sql
create trigger trigsex1 on 学生表 after insert,update 
as 
begin
 declare @sex char(2)
 select @sex=性别 from inserted
 if(@sex<>'男' and @sex<>'女')
  begin
   raiserror('性别只能是男或女',16,1)
   rollback
  end  
end

insert into 学生表(学号,姓名,性别)values('10111','李四六','中') 
select * from 学生表
update 学生表 set 性别='中' where 姓名='李九三'
```

解释：先执行上面insert命令，已经把数据从inserted临时表插入到了物理表中了，再自动执行trigsex1,才发现数据不对，再执行rollback滚回执行，把原来插入到物理表中新人删除.----先操作再触发，所以叫后触发器。

例：建立一个后触发器，当向成绩表中插入或修改记录时，如果插入或修改的数据与学生表中数据不匹配（无这个学生时，即要插入个学生学号不事先在学生表中存在），则此成绩记录无效要删除

```sql
create trigger trigmy1 on 成绩表 after insert,update as 
begin
 declare @sno char(9)
 select @sno=学号 from inserted
 if not exists(select * from 学生表 where 学号=@sno)
  begin
   raiserror('学生信息不存在，先到学生表增加此学生',16,1)
   rollback
  end
end

insert into 成绩表(学号,课程号,成绩)values('001','D01',88)
```

例：限制表中职工的基本工资必须在相应工作的最低工资和最高工资之间

职工表


| 工号 | 姓名 | 工种号 | 性别 | 基本工资 |
| ---- | ---- | ------ | ---- | -------- |
| 101  | 张三 | 002    | 男   | 1900     |
| 102  | 李四 | 001    | 女   | 1200     |

工作表

| 工种号 | 工种 | 最低工资 | 最高工资 |
| ------ | ---- | -------- | -------- |
| 001    | 车工 | 1500     | 3500     |
| 002    | 钳工 | 1700     | 3200     |

触发器：

```sql
Create trigger tri1 on 职工表 after insert,update 
as
If exists(select * from 职工表 a inner join 工作表 b On a.工种号=b.工种号 Where 基本工资 not between 最低工资 and 最高工资)
 Rollback
```

例：教务处要限制老师随便修改学生的已登记成绩，不能将原来已经登记的不及格成绩修改为及格.如果违反约束，提出警告

(建立新表时使用完整性约束无法实现)

```sql
create trigger trimy2 on 成绩表 after update as
 if exists
 (select * from inserted a join deleted b on a.学号=b.学号  where b.成绩<a.成绩 and b.成绩<60 and a.成绩>=60)
  begin
   rollback
   print '不能将不及格成绩随意修改'
  end
  
update 成绩表 set 成绩=67 where 学号='2009010101' and 课程号='103'
```

# 前置触发器：For instead of 

 当条件满足时，使用指定的语句去替换引起触发的逻辑错误语句。也就是说，先(前)判断条件，再操作。

例：使用前置触发器实现：限制表中职工的基本工作必须在相应工作的最低工资和最高工资之间

 ```sql
Create trigger trimy3 on 职工表 instead of insert as
 If not exitst (Select * from inserted a join 工种表 b on a.工种号=b.工种号 where 基本工资 not between 最低工资 and 最高工资)
 
 Insert into 职工表 select * from inserted
 ```

解释：当不存在不满足业务逻辑的记录时，再把inserted临时表的数据插入到物理表。

