---
title: 【C++】内存模型与名称空间
author: zhugenmi
date: 2024-10-12
categories: [C++, C++ Primer]
tags: [c++]
---
## 单独编译

头文件常包含的内容：函数原型、使用`#define`或`const`定义的符号常量、结构声明、类声明、模板声明、内联声明。

若头文件中文件名包含在尖括号中，则C++编译器将在存储标准头文件的主机系统的文件系统中查找；若文件包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录。

在同一个文件中只能将同一个头文件包含一次。避免方法：基于预处理器编译指令`#ifndef`与`#endif`（编译器将查看这之间的内容，让它忽略除第一次包含之外的所有内容）

## 存储持续性、作用域和链接性

1. 自动存储持续性：在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时其内存被释放。
2. 静态存储持续性：在函数定义外定义的变量和使用关键字`static`定义的变量的存储持续性都为静态。（在程序运行过程中都存在）。
3. 线程存储持续性：多核处理器，让程序能将计算放在可并行处理的不同线程中，若变量是使用关键字`thread_local`声明的，则其生命周期与所属线程一样长。
4. 动态存储持续性：用`new`运算符分配的内存将一直存在，直到使用`delete`运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时也被称为自由存储或堆。

## 五种变量存储方式

| 存储描述         | 持续性 | 作用域 | 链接性 | 如何声明                     |
| ---------------- | ------ | ------ | ------ | ---------------------------- |
| 自动             | 自动   | 代码块 | 无     | 在代码块中                   |
| 寄存器           | 自动   | 代码块 | 无     | 代码块中，关键字`register`   |
| 静态，无链接性   | 静态   | 代码块 | 无     | 代码块中，关键字`static`     |
| 静态，外部链接性 | 静态   | 文件   | 外部   | 不在任何函数内               |
| 静态，内部链接性 | 静态   | 文件   | 内部   | 不在任何函数内，使用`static` |

1. 作用域和链接
   作用域描述了名称在文件（翻译单元）的多大范围可见。作用域为全局（文件作用域）的变量在定义位置到文件结尾之间都可用；自动变量的作用域为局部；在函数原型作用域中使用的名称只在包含参数列表的括号内可用；在类中声明的成员的作用域为整个类；在名称空间中声明的变量的作用域为整个名称空间；C++**函数**的作用域可以是整个类或整个名称空间（包括全局的），但不能是局部的（不能在代码块内定义函数）。
   链接性描述了名称如何在不同单元间共享；链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享
2. 自动存储持续性
   默认情况下，在函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性。代码块中定义的变量的存在时间和作用域将被限制在该代码块内。
   可以使用任何在声明时其值为已知的表达式来初始化自动变量。
   程序使用两个指针来跟踪栈，一个指针指向栈底—栈的开始位置，另一个指针指向堆顶—下一个可用内存单元，栈是后进先出的，即最后加入到栈中的变量首先被弹出。
   关键字`register`建议编译器使用CPU寄存器来存储自动变量。
3. 静态持续变量
   C++为静态存储持续性变量提供了3种链接性：外部链接性（可在其它文件中访问）、内部链接性（只能在当前文件中访问）、无链接性（只能在当前函数和代码块中访问）
   所有的静态持续变量都有以下初始化特征：未被初始化的静态变量的所有位都被设置成0. 这种变量被称为零初始化的，也可对静态变量进行常量表达式初始化和动态初始化。
4. 静态持续性、外部链接性
   链接性为外部的变量通常简称为外部变量，它们的存储持续性为静态，作用域为整个文件。
   C++提供两种变量声明：一是定义声明（给变量分配内存空间），另一种是引用声明（引用已有变量，使用关键字`extern`且不进行初始化）。
   作用域解析运算符（`：：`）放在变量名前表示使用变量的全局版本。程序越能避免对数据进行不必要的访问，就越能保持数据的完整性。通常情况下应使用局部变量。
5. 静态持续性、内部链接性
   将`static`限定符用于作用域为整个文件的变量时，该变量的链接性将为内部的。链接性为内部的变量只能在其所属的文件中使用；链接性为外部的常规外部变量可以在其他文件中使用。
   如文件中定义了一个静态外部变量，其名称与另一个文件中声明的常规外部变量相同，则在该文件中，静态变量将隐藏常规外部变量。
   在多文件程序中，可以在一个文件（且只能在一个文件）中定义一个外部变量。使用该变量的其他文件必须使用extern声明它。
6. 静态存储持续性、无链接性
   将`static`限定符用于在代码块中定义的变量。其存储持续性为静态的。若初始化了静态局部变量，则程序只在启动时进行一次初始化，之后再调用函数时将不会像自动变量那样再次被初始化。

7. 函数和链接性
   所有的函数的存储持续性都自动为静态的。即在整个程序执行期间一直存在。默认情况下，函数的链接性为外部的，即可在文件间共享（可以在函数原型中使用`extern`）。使用`static`将函数的链接性设置为内部的，使之只能在一个文件中使用，必须同时在原型和函数定义中使用`static`。C++要求同一个函数的所有内联定义都必须相同，对于每个非内联函数，程序只能包含一个定义。
8. 语言链接性
   链接程序要求每个不同的函数都有不同的符号名。C++编译器执行名称矫正或名称修饰，为重载函数生成不同的符号名称。

## 说明符和限定符

1. 存储说明符：`auto`（自动类型推断）、`register`（寄存器存储，C++11中显式的指出变量是自动的）、`static`、`extern`（引用声明）、`thread_local`（指出变量的持续性与其所属线程的持续性相同）、`mutable`（根据const解释）
2. CV-限定符：`const`、`volatile`（即使程序代码没有对内存单元进行修改，其值也可能发生改变，该关键字的作用是改善编译器的优化能力）
   `mutable`：可用它指出，即使结构（或类）变量为`const`，其某个成员也可被修改。
3. 默认情况下全局变量的链接性为外部的，但`const`全局变量的链接性为内部的。即在C++看来，全局`const`定义就像使用了static说明符一样，这还意味着每个文件都有自己的一组常量，而不是所有文件共享一组常量。
4. 鉴于单个`const`在多个文件间共享，因此只有一个文件可对其进行初始化。