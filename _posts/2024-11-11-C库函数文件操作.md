---
title: C库函数文件操作1
author: zhugenmi
date: 2024-11-11 10:00 +0800
categories: [C/C++, C语言编程]
tags: [c]
description: 
---

### C库函数

C文件操作用库函数实现，包含在`stdio.h`中，系统自动打开和关闭三个标准文件：

- 标准输入-键盘（stdin）
- 标准输出-显示器（stdout）
- 标准出错输出-显示器（stderr）

### 文件打开—fopen()

函数原型：

```c
FILE *fopen(const char *filename, const char *mode)
```

该函数使用给定的模式 mode 打开 filename 所指向的文件。其中mode值为以下：

| 文件使用方式 | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| "r"          | 打开一个用于读取的文件。该文件必须存在。                     |
| "w"          | 创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。 |
| "a"          | 追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。 |
| "r+"         | 打开一个用于更新的文件，可读取也可写入。该文件必须存在。     |
| "w+"         | 创建一个用于读写的空文件。                                   |
| "a+"         | 打开一个用于读取和追加的文件。                               |

返回值：该函数返回一个 指向文件结构体的`FILE` 指针。否则返回 `NULL`，且设置全局变量 `errno` 来标识错误。

### 文件读/写

函数原型：

```c
size_t fread ( void *ptr, size_t size, size_t count, FILE *fp );
size_t fwrite ( void *ptr, size_t size, size_t count, FILE *fp );
```

`fread()` 函数用来从指定文件中读取块数据。所谓块数据，也就是若干个字节的数据，可以是一个字符，可以是一个字符串，可以是多行数据，并没有什么限制。对参数的说明：

- `ptr` 为内存区块的指针，它可以是数组、变量、结构体等。`fread()` 中的 `ptr` 用来存放读取到的数据，`fwrite()` 中的 `ptr` 用来存放要写入的数据。
- `size`：表示每个数据块的字节数。
- `count`：表示要读写的数据块的块数。
- `fp`：表示文件指针。

理论上，每次读写 `size*count` 个字节的数据。

返回值：返回成功读写的块数，也即 `count`。
如果返回值小于 count：

- 对于 `fwrite()` 来说，肯定发生了写入错误，可以用 `ferror()` 函数检测。
- 对于 `fread()` 来说，可能读到了文件末尾，可能发生了错误，可以用 `ferror()` 或 `feof()` 检测。

### 文件关闭—fclose()

函数原型：`fclose(fp)`
作用：关闭fp指向的文件，使文件指针变量与文件“脱销”，释放文件结构体和文件指针。正常关闭返回0；出错时返回非0；

### C库函数读写文件示例

编程，打开文件a.txt，将文件中的内容复制到文件c.txt中

```c
#include<stdio.h>
#include<stdlib.h>
#include<fcntl.h> //文件信息控制
#define count 1 //数据块的个数
int main(int args,char*argv[])
{
        FILE *fp1,*fp2;
        long len=0;
        char *p;
        p=(char*)malloc(sizeof(char)*count);
        fp1=fopen("a.txt","r"); //以只读方式打开文件
        if(fp1==NULL)
        {
                printf("Open a.txt fail!");
                exit(1);
        }
        fp2=fopen("c.txt","w+");
        if(fp2==NULL)
        {
                printf("Open c.txt fail!");
                exit(1);
        }
        while(fread(p,sizeof(char),count,fp1)==1) //读取一个字符
        {
                fwrite(p,sizeof(char),count,fp2);
                len++;
        }
        fclose(fp1);
        fclose(fp2);
        free(p); //释放空间
        return 0;
}
```